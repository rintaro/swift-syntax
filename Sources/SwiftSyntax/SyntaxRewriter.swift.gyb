%{
  from gyb_syntax_support import *
  # -*- mode: Swift -*-
  # Ignore the following admonition it applies to the resulting .swift file only
}%
//// Automatically Generated From SyntaxFactory.swift.gyb.
//// Do Not Edit Directly!
//===------------ SyntaxRewriter.swift - Syntax Rewriter class ------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
//
// This file defines the SyntaxRewriter, a class that performs a standard walk
// and tree-rebuilding pattern.
//
// Subclassers of this class can override the walking behavior for any syntax
// node and transform nodes however they like.
//
//===----------------------------------------------------------------------===//

open class SyntaxRewriter {
  public init() {}

% for node in SYNTAX_NODES:
%   if is_visitable(node):
  /// Visit a `${node.name}`.
  ///   - Parameter node: the node that is being visited
  ///   - Returns: the rewritten node
  open func visit(_ node: ${node.name}) -> ${node.base_type} {
    return ${node.base_type}(visitChildren(node))
  }

%   end
% end

  /// Visit a `TokenSyntax`.
  ///   - Parameter node: the node that is being visited
  ///   - Returns: the rewritten node
  open func visit(_ token: TokenSyntax) -> Syntax {
    return Syntax(token)
  }
  
  /// Visit an `UnknownSyntax`.
  ///   - Parameter node: the node that is being visited
  ///   - Returns: the rewritten node
  open func visit(_ node: UnknownSyntax) -> Syntax {
    return Syntax(visitChildren(node))
  }

  /// The function called before visiting the node and its descendents.
  ///   - node: the node we are about to visit.
  open func visitPre(_ node: Syntax) {}

  /// Override point to choose custom visitation dispatch instead of the
  /// specialized `visit(_:)` methods. Use this instead of those methods if
  /// you intend to dynamically dispatch rewriting behavior.
  /// - note: If this method returns a non-nil result, the specialized
  ///         `visit(_:)` methods will not be called for this node and the 
  ///         visited node will be replaced by the returned node in the 
  ///         rewritten tree.
  open func visitAny(_ node: Syntax) -> Syntax? {
    return nil
  }

  /// The function called after visiting the node and its descendents.
  ///   - node: the node we just finished visiting.
  open func visitPost(_ node: Syntax) {}

  /// Visit any Syntax node. 
  ///   - Parameter node: the node that is being visited
  ///   - Returns: the rewritten node
  public func visit(_ syntax: Syntax) -> Syntax {
    return visitImpl(syntax)
  }

% for node in SYNTAX_NODES:
  /// Implementation detail of visit(_:). Do not call directly.
  private func visitImpl${node.name}(_ syntax: Syntax) -> Syntax {
    visitPre(syntax)
    defer { visitPost(syntax) }
    if let newNode = visitAny(syntax) { return newNode }
%   if node.is_base():
    return visit(Unknown${node.name}(data: syntax.data)).syntax
%   else:
    return visit(${node.name}(data: syntax.data)).syntax
%   end
  }

% end

  /// Implementation detail of visit(_:). Do not call directly.
  private func visitImplTokenSyntax(_ syntax: Syntax) -> Syntax {
    visitPre(syntax)
    defer { visitPost(syntax) }
    if let newNode = visitAny(syntax) { return newNode }
    return visit(TokenSyntax(data: syntax.data)).syntax
  }

  /// Implementation detail of visit(_:). Do not call directly.
  private func visitImplUnknownSyntax(_ syntax: Syntax) -> Syntax {
    visitPre(syntax)
    defer { visitPost(syntax) }
    if let newNode = visitAny(syntax) { return newNode }
    return visit(UnknownSyntax(data: syntax.data)).syntax
  }

// SwiftSyntax requires a lot of stack space in debug builds for syntax tree
// rewriting. In scenarios with reduced stack space (in particular dispatch 
// queues), this easily results in a stack overflow. To work around this issue, 
// use a less performant but also less stack-hungry version of SwiftSyntax's 
// SyntaxRewriter in debug builds.
#if DEBUG

  /// Implementation detail of visit(_:). Do not call directly.
  /// 
  /// Returns the function that shall be called to visit a specific syntax node.
  ///
  /// To determine the correct specific visitation function for a syntax node,
  /// we need to switch through a huge switch statement that covers all syntax
  /// types. In debug builds, the cases of this switch statement do not share 
  /// stack space (rdar://55929175). Because of this, the switch statement 
  /// requires allocates about 15KB of stack space. In scenarios with reduced 
  /// stack size (in particular dispatch queues), this often results in a stack 
  /// overflow during syntax tree rewriting.
  /// 
  /// To circumvent this problem, make calling the specific visitation function 
  /// a two-step process: First determine the function to call in this function
  /// and return a reference to it, then call it. This way, the stack frame
  /// that determines the correct visitiation function will be popped of the
  /// stack before the function is being called, making the switch's stack
  /// space transient instead of having it linger in the call stack.
  private func visitationFunc(for syntax: Syntax) -> ((Syntax) -> Syntax) {
    switch syntax.syntaxKind {
    case .token:
      return visitImplTokenSyntax
    case .unknown:
      return visitImplUnknownSyntax
  % for node in SYNTAX_NODES:
    case .${node.swift_syntax_kind}:
      return visitImpl${node.name}
  % end
    }
  }

  private func visitImpl(_ syntax: Syntax) -> Syntax {
    return visitationFunc(for: syntax)(syntax)
  }

#else

  private func visitImpl(_ syntax: Syntax) -> Syntax {
    switch syntax.syntaxKind {
    case .token:
      return visitImplTokenSyntax(syntax)
    case .unknown:
      return visitImplUnknownSyntax(syntax)
  % for node in SYNTAX_NODES:
    case .${node.swift_syntax_kind}:
      return visitImpl${node.name}(syntax)
  % end
    }
  }

#endif

  private func visitChildren<SyntaxType: SyntaxProtocol>(
    _ node: SyntaxType
  ) -> SyntaxType {
    // Walk over all children of this node and rewrite them. Don't store any
    // rewritten nodes until the first non-`nil` value is encountered. When this
    // happens, retrieve all previous syntax nodes from the parent node to
    // initialize the new layout. Once we know that we have to rewrite the
    // layout, we need to collect all futher children, regardless of whether
    // they are rewritten or not.

    // newLayout is nil until the first child node is rewritten.
    var newLayout: ContiguousArray<RawSyntax?>?

    for child in node.children {
      let rewritten = visit(child)
      if rewritten.raw.id != child.raw.id {
        // The node was rewritten, let's handle it
        if newLayout == nil {
          // We have not yet prepared the new layout array. Copy the current
          // layout now.
          newLayout = ContiguousArray<RawSyntax?>(node.raw.children)
        }

        // Now that we know we have a new layout. Replace the child.
        newLayout![child.indexInParent!] = rewritten.raw
      }
    }

    if let newLayout = newLayout {
      // A child node was rewritten. Build the updated node.

      // Sanity check, ensure the new children are the same length.
      assert(newLayout.count == node.raw.children.count)


      let arena = node.arena
      let newRaw = node.raw.replacingLayout(with: newLayout, arena: arena)
      return SyntaxType(Syntax(raw: newRaw, arena: arena))!
    } else {
      // No child node was rewritten. So no need to change this node as well.
      return node
    }
  }
}
