%{
  from gyb_syntax_support import *
  NODE_MAP = create_node_map()
  # -*- mode: Swift -*-
  # Ignore the following admonition it applies to the resulting .swift file only
}%
//// Automatically Generated From SyntaxCollections.swift.gyb.
//// Do Not Edit Directly!
//===------------ SyntaxCollections.swift.gyb - Syntax Collection ---------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//


% for node in SYNTAX_NODES:
%   if node.collection_element:
%     element_node = NODE_MAP.get(node.collection_element)

% if node.description:
%   for line in dedented_lines(node.description):
/// ${line}
%   end
% else:
/// `${node.name}` represents a collection of one or more
/// `${node.collection_element_type}` nodes. ${node.name} behaves
/// as a regular Swift collection, and has accessors that return new
/// versions of the collection with different children.
% end
public struct ${node.name}: SyntaxCollection, SyntaxHashable {
  public typealias Element = ${node.collection_element_type}

  public let _syntaxNode: Syntax

  /// Converts the given `Syntax` node to a `${node.name}` if possible. Returns
  /// `nil` if the conversion is not possible.
  public init?(_ syntax: Syntax) {
    guard syntax.raw.kind == .${node.swift_syntax_kind} else { return nil }
    self._syntaxNode = syntax
  }

  /// Creates a Syntax node from the provided root and data. This assumes 
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    assert(data.raw.kind == .${node.swift_syntax_kind})
    self._syntaxNode = Syntax(data)
  }

  public init(_ children: [${node.collection_element_type}]) {
    let raw = RawSyntax.makeLayout(kind: SyntaxKind.${node.swift_syntax_kind},
      from: children.map { $0.raw }, arena: .default)
    let data = SyntaxData.forRoot(raw)
    self.init(data)
  }

  public var syntaxNodeType: SyntaxProtocol.Type {
    return Swift.type(of: self)
  }

  /// Creates a new `${node.name}` by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new `${node.name}` with the new layout underlying it.
  @_spi(RawSyntax)
  public func _replacingLayout(_ layout: [RawSyntax?]) -> Self {
    return ${node.name}(data.replacingLayout(with: layout))
  }

  public subscript(i: Index) -> ${node.collection_element_type} {
    ${node.collection_element_type}(self._childData(at: i))
  }
}
%   end
% end

% for node in SYNTAX_NODES:
%   if node.is_syntax_collection():
extension ${node.name}: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(self, unlabeledChildren: self.map{ $0 })
  }
}
%   end
% end
