%{
  # -*- mode: Swift -*-
  from gyb_syntax_support import *
  from gyb_syntax_support.Traits import TRAITS
  NODE_MAP = create_node_map()
  # Ignore the following admonition it applies to the resulting .swift file only
}%
//// Automatically Generated From SyntaxNodes.swift.gyb.
//// Do Not Edit Directly!
//===---------- SyntaxBaseNodes.swift - Syntax Node definitions -----------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

% for node in SYNTAX_NODES:
%   base_type = node.base_type
%   if not node.is_base():
%     pass
%   else:

// MARK: - ${node.name}

/// Protocol to which all `${node.name}` nodes conform. Extension point to add
/// common methods to all `${node.name}` nodes.
/// DO NOT CONFORM TO THIS PROTOCOL YOURSELF!
public protocol ${node.name}Protocol: ${node.base_type}Protocol {}

public extension Syntax {
  /// Check whether the non-type erased version of this syntax node conforms to
  /// ${node.name}Protocol.
  /// Note that this will incur an existential conversion.
  func isProtocol(_: ${node.name}Protocol.Protocol) -> Bool {
    return self.asProtocol(${node.name}Protocol.self) != nil
  }

  /// Return the non-type erased version of this syntax node if it conforms to
  /// ${node.name}Protocol. Otherwise return nil.
  /// Note that this will incur an existential conversion.
  func asProtocol(_: ${node.name}Protocol.Protocol) -> ${node.name}Protocol? {
    return self.asProtocol(SyntaxProtocol.self) as? ${node.name}Protocol
  }
}


public struct ${node.name}: ${node.base_type}Protocol, Hashable, Identifiable {
  public typealias ID = SyntaxIdentifier
  public static func isValid(syntaxKind: SyntaxKind) -> Bool {
    Raw${node.name}.isValid(syntaxKind: syntaxKind)
  }
  public let syntax: Syntax

  /// Initialize `${node.name}` unsafely assuming `syntax` is valid.
  @usableFromInline
  init(data: SyntaxData) {
    assert(Self.isValid(syntaxKind: data.raw.syntaxKind))
    self.syntax = Syntax(data: data)
  }

  /// Checked cast `other` to `${node.name}` if possible.
  @inlinable
  public init?<Node: SyntaxProtocol>(_ other: Node) {
    guard Self.isValid(syntaxKind: other.syntax.syntaxKind) else { return nil }
    self.init(data: other.data)
  }

  /// Create a `${node.name}` node from a specialized syntax node.
  public init<Node: ${node.name}Protocol>(_ other: Node) {
    // We know T is valid for this protocol.
    self.init(data: other.data)
  }

  /// Syntax nodes always conform to `${node.name}Protocol`. This API is just
  /// added for consistency.
  /// Note that this will incur an existential conversion.
  @available(*, deprecated, message: "Expression always evaluates to true")
  public func isProtocol(_: ${node.name}Protocol.Protocol) -> Bool {
    return true
  }

  /// Return the non-type erased version of this syntax node.
  /// Note that this will incur an existential conversion.
  public func asProtocol(_: ${node.name}Protocol.Protocol) -> ${node.name}Protocol {
    return Syntax(self).asProtocol(${node.name}Protocol.self)!
  }
}

extension ${node.name}: CustomReflectable {
  /// Reconstructs the real syntax type for this type from the node's kind and
  /// provides a mirror that reflects this type.
  public var customMirror: Mirror {
    return Mirror(reflecting: Syntax(self).asProtocol(SyntaxProtocol.self))
  }
}

%   end
% end
